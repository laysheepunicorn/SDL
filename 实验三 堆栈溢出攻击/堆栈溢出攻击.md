# 堆栈溢出攻击

## 实验背景

- 堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界。结果覆盖了老的堆栈数据。
- 字符串太长，数组容纳不下，只好向内存顶部继续写字符串。由于堆栈的生长方向与内存的生长方向相反，这些字符覆盖了堆栈的老的元素。如图我们可以发现，EBP，ret都已经被剩下的字符覆盖了。在main返回的时候，就会把字符串的ASCII码作为返回地址，CPU会试图执行这个返回地址处的指令，结果出现错误。这就是一次堆栈溢出。

## 实验过程

1. 实验准备
    - 像缓冲区溢出实验中一样关闭各种检查
    - 设置固定基址
        ![ ](image\基址.JPG)
    - 实验代码
        ![ ](image\代码.JPG)
2. 实验步骤
    - 调试代码，发现堆溢出的部分正好是字符"1238"，因为对应返回的地址是0x38333231
        ![ ](image\堆溢出.JPG)
    - 因为基址固定，hacked函数的地址也固定为0x21311580
        ![ ](image\hacked函数.JPG)
    - 更改字符串内容，使溢出的部分正好为hacked函数的地址，这样溢出的时候返回地址就会到hacked函数
        ![ ](image\hacked成功.JPG)